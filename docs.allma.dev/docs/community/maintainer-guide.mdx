---
title: Maintainer Guide
sidebar_position: 4
---

# The Allma Maintainer's Guide

This document outlines the responsibilities, workflow, and best practices for maintainers of the Allma project. Its purpose is to ensure that we review contributions consistently, maintain a high bar for quality, and foster a welcoming and collaborative community.

## The Maintainer's Pledge

As a maintainer of Allma, you are a steward of the project and a mentor to its contributors. Your primary goals are:

1.  **Guardian of Quality:** Uphold the project's coding standards, architectural principles, and testing requirements.
2.  **Enabler of Contributions:** Provide timely, constructive, and respectful feedback to help contributors get their work merged.
3.  **Community Builder:** Thank contributors for their effort and make them feel valued, regardless of whether their contribution is merged.

## The Pull Request Review Workflow

We follow a structured process to ensure every Pull Request (PR) is reviewed thoroughly and fairly.

### Step 1: Initial Triage (The First 5 Minutes)

Before diving into the code, perform a quick triage to ensure the PR is ready for review.

1.  **Check the Description & Linked Issue:**
    -   Is the description clear? Does it explain the "what" and the "why"?
    -   **Crucially, does it link to a GitHub Issue using a keyword like `Closes #123`?** If not, ask the contributor to add it. PRs without a linked issue should not be reviewed.

2.  **Check for a Changeset:**
    -   If the PR is a `feat` or `fix` that affects any of the published packages, it **must** include a new file in the `.changeset/` directory.
    -   If a changeset is missing, do not review the code. Ask the contributor to add one by running `npm run changeset`.
    -   *Example Comment:* "Thanks for this feature! To make sure this gets into the next release, could you please run `npm run changeset`, commit the generated file, and push it to this branch? You can find more info in our Contribution Guide."

3.  **Check the CI/CD Status:**
    -   Look for the automated checks at the bottom of the PR. Are they all green?
    -   If a check is failing (e.g., Lint, Tests), ask the contributor to fix the failing checks first.

4.  **Assign Yourself:** If the PR is ready for review, assign it to yourself to signal to other maintainers that it's being handled.

### Step 2: The Code Review Checklist

This is the deep dive. Pull the contributor's branch down to test it locally. Review the code against our core principles.

```bash
# Example of checking out a contributor's PR locally
git fetch upstream pull/PR_NUMBER/head:BRANCH_NAME
git checkout BRANCH_NAME
```

#### âœ… Correctness & Logic
-   Does the code solve the problem described in the linked issue?
-   Does it introduce any new bugs or regressions?
-   Are there any obvious edge cases that have been missed? (e.g., null inputs, empty arrays, race conditions).

#### âœ… Architecture & Design
-   Does the code adhere to our "Developer-as-Consumer" pattern? Is the core logic isolated and testable?
-   Does it follow our SOLID and DRY principles? Is there duplicated code that should be refactored into the `@allma/core-sdk`?
-   If it adds new infrastructure, does it follow the Principle of Least Privilege in the `allma-cdk` package?

#### âœ… Readability & Style
-   Is the code clear, concise, and easy to understand?
-   Are variable and function names meaningful?
-   Are comments used to explain the *why*, not the *what*?
-   Does it conform to our ESLint and Prettier rules? (The CI check should catch this, but it's good to double-check).

#### âœ… Testing
-   Does the PR include new tests for the added feature or bug fix?
-   Do the tests cover the important success paths and failure cases?
-   Are all existing tests still passing?

#### âœ… Documentation
-   If the change affects users or other developers, has the corresponding documentation been updated? (e.g., new step module, API endpoint change).
-   Are public functions and complex types documented with JSDoc comments?

### Step 3: Providing Feedback

How we communicate is as important as the feedback itself.

-   **Be Kind and Constructive:** Start with a positive comment. Thank the contributor. Frame your feedback as suggestions or questions.
    -   **Good:** "This is a great start! I'm wondering if we could handle the case where the input array is empty. What do you think about adding a check at the beginning of the function?"
    -   **Bad:** "You forgot to handle empty arrays. This will break."

-   **Use GitHub's Tools:**
    -   **Suggestions:** For small changes, use the "Suggest change" feature to provide a ready-to-commit fix.
    -   **Batch Comments:** Group your comments and submit them as a single review to avoid overwhelming the contributor with notifications.

-   **Be Clear About Requirements:** Prefix your comments to distinguish between mandatory changes and optional suggestions.
    -   `[Blocking]:` A required change that must be addressed before the PR can be merged.
    -   `[Suggestion]:` An optional improvement or idea for future consideration.
    -   `[Question]:` A request for clarification.
    -   `[Nitpick]:` A minor stylistic preference that isn't blocking.

### Step 4: Approving and Merging Feature PRs

1.  **Approval:** A PR should have at least **one approval** from a maintainer other than the author. For significant architectural changes, aim for two approvals.

2.  **Merge Strategy:** Always use the **"Squash and merge"** option for feature PRs. This combines all of the PR's commits into a single, clean commit on the `main` branch. This keeps our `main` branch history tidy and readable.

3.  **The Squash Commit Message:** The title should be a clear, imperative summary of the changes (e.g., `Add string case converter module`). The body can be the auto-generated list of commits. The exact format is less critical now, as it no longer drives the release process.

### Step 5: The Release Process (The Bot Takes Over)

Once you merge a feature PR containing a changeset into `main`, our automated release process begins:

1.  **Bot Creates a PR:** The Changesets GitHub Action will detect the new changeset file(s) on `main`. It will then automatically open a new Pull Request titled **"Upcoming Release"**.
2.  **Review the Release PR:** This special PR contains all the version bumps for the affected packages and the aggregated changelogs. It is the single source of truth for what will be published. This is the final chance to sanity-check the upcoming release.
3.  **Trigger the Publish:** When you are ready to publish the new versions to npm, simply **Merge** the "Upcoming Release" PR. This action will trigger the final step in our CI, which builds all the packages and publishes them to the npm registry.

### Step 6: Post-Merge Celebration

-   **Thank the Contributor:** Leave a final comment on the original, merged feature PR thanking the contributor for their work (e.g., "Thanks for the great contribution, @username! ðŸŽ‰ This will be included in our next release.").
-   **Delete the Branch:** GitHub will prompt you to delete the source branch after merging. Do it to keep the repository clean.
